package events

import (
    "encoding/json"
    "fmt"
    "time"

    "github.com/nats-io/nats.go"
    "implementation/auth"
)

type Event struct {
    ID        string          `json:"id"`
    Data      json.RawMessage `json:"data"`
    JWT       string          `json:"jwt"`
    EventAuth auth.EventToken `json:"event_auth"`
}

type Publisher struct {
    ID           string
    natsConn     *nats.Conn
    tokenManager *auth.TokenManager
}

type Subscriber struct {
    ID           string
    natsConn     *nats.Conn
    tokenManager *auth.TokenManager
}


/*  NewPublisher function
    id string: identifier for the publisher
    nc *nats.Conn: the NATS connection that the publisher will connect to
    tm *auth.TokenManager: the TokenManager for the publisher
*/
func NewPublisher(id string, nc *nats.Conn, tm *auth.TokenManager) *Publisher {
    p := Publisher{
        ID:           id,
        natsConn:     nc,
        tokenManager: tm,
    }   
    return &p
}
/*  NewSubscriber() -> initializes and returns a new Subscriber
    id string: identifier for the subscriber
    nc *nats.Conn: the NATS connection that the subscriber will connect to
    tm *auth.TokenManager: the TokenManager for the subscriber
*/
func NewSubscriber(id string, nc *nats.Conn, tm *auth.TokenManager) *Subscriber {
    s := Subscriber{
        ID:           id,
        natsConn:     nc,
        tokenManager: tm,
    }   
    

    return &s
}
/*
    Publish() ->  struct method to publish data
    topic -> the topic the publisher will write to
    eventType -> specifies the type of event
    data -> the actual data being generated by the specified interface
*/

func (p *Publisher) Publish(topic string, eventType string, data interface{}) error {
    // marshal data to json
    // terminate if we can't read data!
    payload, err := json.Marshal(data)
    if err != nil {
        return fmt.Errorf("Couldln't marshal data! [%v]", err)
    }

    // uses the publisher's token manager to create a JWT access token
    // terminate if we can't create an access token!
    jwt, err := p.tokenManager.CreateJWT(p.ID)
    if err != nil {
        return fmt.Errorf("Couldn't create JWT! [%v]", err)
    }

    // generates an event token for the publisher 
    // terminate routine if we can't create an event token!!
    eventToken, err := p.tokenManager.CreateEventToken(p.ID, eventType, payload)
    if err != nil {
        return fmt.Errorf("Couldn't create event token! [%v]", err)
    }

    // creates a new event, all the preqreqs are true
    // this is what the subscribers will see
    event := Event{
        ID:        fmt.Sprintf("%d", time.Now().UnixNano()),
        Data:      payload,
        JWT:       jwt,
        EventAuth: eventToken,
    }

    // marshall the event now, since we have thrown the data onto an event struct
    // think of this as the packet that the subscribers will receive from the broker (nats)
    eventBytes, err := json.Marshal(event)
    if err != nil {
        return fmt.Errorf("failed to marshal event: %v", err)
    }

    // publish the EVENT to the TOPIC in the NATS CONNECTION
    return p.natsConn.Publish(topic, eventBytes)
}

/*
    Subscribe() -> struct method to subscribe to topic
*/
func (s *Subscriber) Subscribe(topic string, handler func(interface{}) error) error {
    _, err := s.natsConn.Subscribe(topic, func(msg *nats.Msg) {
        var event Event
        // unmarshall (unpack it) the raw data from the publisher
        if err := json.Unmarshal(msg.Data, &event); err != nil {
            fmt.Printf("Failed to unmarshal event: %v\n", err)
            return
        }

        // verify JWT using the token manager
        if _, err := s.tokenManager.VerifyJWT(event.JWT); err != nil {
            fmt.Printf("JWT verification failed: %v\n", err)
            return
        }

        // verify event token using the token manager
        if err := s.tokenManager.VerifyEventToken(event.EventAuth, event.Data); err != nil {
            fmt.Printf("Event token verification failed: %v\n", err)
            return
        }

        // unpack the EVENT data from the EVENT token
        var data interface{}
        if err := json.Unmarshal(event.Data, &data); err != nil {
            fmt.Printf("Failed to unmarshal event data: %v\n", err)
            return
        }
        
        // call the interface to handle the data
        if err := handler(data); err != nil {
            fmt.Printf("Failed to handle event: %v\n", err)
        }
    })

    return err
}
